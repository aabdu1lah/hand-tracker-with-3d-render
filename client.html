<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Step 8: Complete Spatial OS</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #status { position: absolute; top: 10px; left: 10px; color: #666; font-family: monospace; font-size: 14px; pointer-events: none; }
        #hud { position: absolute; bottom: 20px; width: 100%; text-align: center; pointer-events: none; }
        .hud-text { color: #fff; font-family: sans-serif; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px #000; display: block; }
        .save-text { color: #0f0; font-size: 14px; opacity: 0; transition: opacity 0.5s; }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>
    <div id="status">System Ready</div>
    <div id="hud">
        <span id="mode-indicator" class="hud-text">MODE: INTERACT</span>
        <span id="save-indicator" class="save-text">STATE SAVED</span>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIG ---
        const WORLD_SCALE = 10; 
        const SMOOTHING = 0.2; 
        
        // --- SCENE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 100);
        camera.position.set(0, 3, 10); 
        camera.lookAt(0, 1, 0);
        scene.add(camera); // Required for HUD buttons

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0x444444));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(5, 10, 5);
        scene.add(dirLight);

        // --- WORLD ROOT ---
        const worldGroup = new THREE.Group();
        scene.add(worldGroup);

        const grid = new THREE.GridHelper(50, 50, 0x333333, 0x111111);
        grid.position.y = -2;
        worldGroup.add(grid);

        // --- PERSISTENCE ENGINE (Restored from Step 7) ---
        class SceneGraph {
            constructor() {
                this.entities = []; 
            }
            register(entity) { this.entities.push(entity); }
            
            save() {
                // 1. Save World Transform
                const state = {
                    world: {
                        pos: worldGroup.position.toArray(),
                        rot: worldGroup.rotation.toArray(),
                        scale: worldGroup.scale.toArray()
                    },
                    entities: [],
                    drawings: [] // Special store for lines
                };

                // 2. Save Interactive Entities
                this.entities.forEach(e => {
                    state.entities.push({
                        id: e.id,
                        data: e.serialize()
                    });
                });

                // 3. Save Drawings (The Lines)
                worldGroup.children.forEach(child => {
                    if (child.userData.isDrawing) {
                        state.drawings.push(child.userData.points);
                    }
                });
                
                localStorage.setItem('spatial_os_v1', JSON.stringify(state));
                
                const ind = document.getElementById('save-indicator');
                ind.style.opacity = 1;
                setTimeout(() => ind.style.opacity = 0, 1000);
            }

            load() {
                const raw = localStorage.getItem('spatial_os_v1');
                if (!raw) return;
                const state = JSON.parse(raw);

                // Restore World
                worldGroup.position.fromArray(state.world.pos);
                worldGroup.rotation.fromArray(state.world.rot);
                worldGroup.scale.fromArray(state.world.scale);

                // Restore Entities
                state.entities.forEach(saved => {
                    const entity = this.entities.find(e => e.id === saved.id);
                    if (entity) entity.hydrate(saved.data);
                });

                // Restore Drawings
                if (state.drawings) {
                    state.drawings.forEach(pointsData => {
                        const geo = new THREE.BufferGeometry();
                        const points = pointsData.map(p => new THREE.Vector3(p.x, p.y, p.z));
                        geo.setFromPoints(points);
                        const mat = new THREE.LineBasicMaterial({ color: 0xffff00 });
                        const line = new THREE.Line(geo, mat);
                        line.userData = { isDrawing: true, points: pointsData };
                        worldGroup.add(line);
                    });
                }
            }
        }
        const persistence = new SceneGraph();


        // --- TOOLS & MODES ---
        class Tool {
            constructor(name, color) { this.name = name; this.color = color; }
            enter() {} exit() {} update(l, r) {} 
        }

        // TOOL 1: INTERACT
        class InteractTool extends Tool {
            constructor() { super('INTERACT', 0x00ffff); }
            update(l, r) {
                [l, r].forEach(h => { if(h.visible) slider.checkInput(h.smoothTip); });
            }
        }

        // TOOL 2: NAVIGATE (Fixed Rotation)
        class NavigateTool extends Tool {
            constructor() { 
                super('NAVIGATE', 0x00ff00); 
                this.state = { dragging: false, prevMid: new THREE.Vector3(), prevDist: 0, prevAngle: 0 };
            }
            update(leftHand, rightHand) {
                const lPinch = leftHand.visible && leftHand.isPinching;
                const rPinch = rightHand.visible && rightHand.isPinching;

                if (lPinch && rPinch) {
                    const p1 = leftHand.smoothTip;
                    const p2 = rightHand.smoothTip;
                    
                    const currMid = new THREE.Vector3().lerpVectors(p1, p2, 0.5);
                    const currDist = p1.distanceTo(p2);
                    // Rotation Math: Angle between hands in X/Y plane (Steering Wheel)
                    // Note: We map this to World Y Rotation (Tabletop spin)
                    const currAngle = Math.atan2(p2.z - p1.z, p2.x - p1.x);

                    if (!this.state.dragging) {
                        this.state.dragging = true;
                        this.state.prevMid.copy(currMid);
                        this.state.prevDist = currDist;
                        this.state.prevAngle = currAngle;
                    } else {
                        // 1. Translate
                        const delta = new THREE.Vector3().subVectors(currMid, this.state.prevMid);
                        worldGroup.position.add(delta);

                        // 2. Scale
                        const scaleFactor = currDist / this.state.prevDist;
                        if(scaleFactor > 0.9 && scaleFactor < 1.1) {
                            worldGroup.scale.multiplyScalar(scaleFactor);
                        }

                        // 3. Rotate (The Fix)
                        let deltaAngle = currAngle - this.state.prevAngle;
                        // Filter jumps
                        if (Math.abs(deltaAngle) < 0.5) {
                            // Rotate around Vertical Axis (Y)
                            worldGroup.rotateY(-deltaAngle);
                        }

                        this.state.prevMid.copy(currMid);
                        this.state.prevDist = currDist;
                        this.state.prevAngle = currAngle;
                    }
                } else {
                    this.state.dragging = false;
                }
            }
        }

        // TOOL 3: DRAW
        class DrawTool extends Tool {
            constructor() { 
                super('DRAW', 0xffff00); 
                this.currentLine = null;
            }
            update(leftHand, rightHand) {
                if (rightHand.visible) {
                    if (rightHand.isPinching) {
                        if (!this.currentLine) {
                            const geo = new THREE.BufferGeometry();
                            const mat = new THREE.LineBasicMaterial({ color: 0xffff00 });
                            this.currentLine = new THREE.Line(geo, mat);
                            this.currentLine.userData = { isDrawing: true, points: [] };
                            worldGroup.add(this.currentLine);
                        }
                        // Save local points for persistence
                        const localPt = worldGroup.worldToLocal(rightHand.smoothTip.clone());
                        this.currentLine.userData.points.push({x: localPt.x, y: localPt.y, z: localPt.z});
                        
                        // Update Mesh
                        const pointsVec = this.currentLine.userData.points.map(p => new THREE.Vector3(p.x, p.y, p.z));
                        this.currentLine.geometry.setFromPoints(pointsVec);
                    } else {
                        this.currentLine = null;
                    }
                }
            }
        }

        // MODE MANAGER
        class ModeManager {
            constructor() {
                this.modes = { 'INTERACT': new InteractTool(), 'NAVIGATE': new NavigateTool(), 'DRAW': new DrawTool() };
                this.activeTool = this.modes['INTERACT'];
            }
            setMode(key) {
                if (this.modes[key]) {
                    this.activeTool.exit();
                    this.activeTool = this.modes[key];
                    this.activeTool.enter();
                    
                    const ind = document.getElementById('mode-indicator');
                    ind.innerText = `MODE: ${key}`;
                    ind.style.color = '#' + this.activeTool.color.toString(16);
                    leftHand.setColor(this.activeTool.color);
                    rightHand.setColor(this.activeTool.color);
                }
            }
            update(l, r) { this.activeTool.update(l, r); }
        }
        const modeManager = new ModeManager();

        // --- UI DOCK ---
        class ModeButton {
            constructor(label, modeKey, x, color) {
                this.modeKey = modeKey;
                this.mesh = new THREE.Group();
                this.mesh.position.set(x, -2.5, -6.0); 

                const geo = new THREE.BoxGeometry(1.5, 0.5, 0.1);
                const mat = new THREE.MeshStandardMaterial({ color: color });
                this.plate = new THREE.Mesh(geo, mat);
                this.mesh.add(this.plate);

                const canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#fff'; ctx.font = "bold 40px sans-serif";
                ctx.textAlign = "center"; ctx.textBaseline = "middle"; 
                ctx.fillText(label, 128, 64);
                const labelMesh = new THREE.Mesh(new THREE.PlaneGeometry(1.4, 0.7), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true }));
                labelMesh.position.z = 0.06;
                this.mesh.add(labelMesh);

                camera.add(this.mesh); 
            }
            checkInput(fingerPos) {
                const worldPos = new THREE.Vector3();
                this.plate.getWorldPosition(worldPos);
                if (fingerPos.distanceTo(worldPos) < 0.6) {
                    this.plate.scale.set(1.1, 1.1, 1.1);
                    return true;
                }
                this.plate.scale.set(1, 1, 1);
                return false;
            }
        }
        const modeButtons = [
            new ModeButton("INTERACT", 'INTERACT', -2, 0x00ffff),
            new ModeButton("NAVIGATE", 'NAVIGATE', 0, 0x00ff00),
            new ModeButton("DRAW", 'DRAW', 2, 0xffff00)
        ];

        // --- SLIDER (Persistent) ---
        class SpatialSlider {
            constructor() {
                this.id = 'main_slider';
                this.val = 0.5;
                this.mesh = new THREE.Group();
                this.mesh.position.set(0, 2, 0);
                const bar = new THREE.Mesh(new THREE.BoxGeometry(4, 0.2, 0.1), new THREE.MeshStandardMaterial({ color: 0x444444 }));
                this.handle = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.2), new THREE.MeshStandardMaterial({ color: 0x00ffff }));
                this.mesh.add(bar);
                this.mesh.add(this.handle);
                worldGroup.add(this.mesh);
                this.updateVis();
                persistence.register(this); // Track for saving
            }
            updateVis() { this.handle.position.x = (this.val - 0.5) * 4; }
            serialize() { return { val: this.val }; }
            hydrate(data) { this.val = data.val; this.updateVis(); }
            
            checkInput(pos) {
                const local = this.mesh.worldToLocal(pos.clone());
                if (Math.abs(local.y)<0.5 && Math.abs(local.x)<2.5 && Math.abs(local.z)<0.4) {
                    this.val = Math.max(0, Math.min(1, (local.x/4)+0.5));
                    this.updateVis();
                }
            }
        }
        const slider = new SpatialSlider();

        // --- HAND CONTROLLER ---
        class HandController {
            constructor() {
                this.mesh = new THREE.Group();
                this.joints = [];
                const mat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
                for(let i=0; i<21; i++) {
                    this.joints.push(new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), mat));
                    this.mesh.add(this.joints[i]);
                }
                this.stylus = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                this.mesh.add(this.stylus);
                scene.add(this.mesh);
                this.smoothTip = new THREE.Vector3();
                this.visible = false; this.isPinching = false; this.isInitialized = false;
            }
            setColor(hex) { this.joints.forEach(j => j.material.color.setHex(hex)); }
            update(data) {
                this.visible = true; this.mesh.visible = true; this.isPinching = data.pinch;
                const rawVecs = data.landmarks.map(lm => new THREE.Vector3(lm.x * WORLD_SCALE, lm.y * WORLD_SCALE, lm.z * WORLD_SCALE));
                for(let i=0; i<21; i++) this.joints[i].position.copy(rawVecs[i]);
                if(!this.isInitialized) { this.smoothTip.copy(rawVecs[8]); this.isInitialized=true; }
                else { this.smoothTip.lerp(rawVecs[8], SMOOTHING); }
                this.stylus.position.copy(this.smoothTip);
            }
            hide() { this.visible = false; this.mesh.visible = false; }
        }
        const leftHand = new HandController();
        const rightHand = new HandController();

        // --- LOOP ---
        persistence.load(); // Restore state on start
        setInterval(() => persistence.save(), 2000); // Auto-save

        const ws = new WebSocket('ws://localhost:8765');
        ws.onmessage = (e) => {
            const data = JSON.parse(e.data);
            let l=false, r=false;
            if(data.hands) data.hands.forEach(h => {
                if(h.id === 'Left') { leftHand.update(h); l=true; }
                if(h.id === 'Right') { rightHand.update(h); r=true; }
            });
            if(!l) leftHand.hide(); if(!r) rightHand.hide();

            // Mode Switching
            let switched = false;
            if (l) modeButtons.forEach(btn => { if(btn.checkInput(leftHand.smoothTip) && leftHand.isPinching) { modeManager.setMode(btn.modeKey); switched=true; }});
            if (r && !switched) modeButtons.forEach(btn => { if(btn.checkInput(rightHand.smoothTip) && rightHand.isPinching) { modeManager.setMode(btn.modeKey); }});

            modeManager.update(leftHand, rightHand);
        };

        function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
        animate();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

    </script>
</body>
</html>