<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Step 4: Tactile Interaction</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        #status { position: absolute; top: 10px; left: 10px; color: #555; font-family: sans-serif; font-size: 14px; pointer-events: none; }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>
    <div id="status">Waiting for Hands...</div>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIG ---
        const WORLD_SCALE = 10; 
        const GRAB_RADIUS = 2.0; 
        const SMOOTHING = 0.15;

        // --- SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        // Camera
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 15);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Global Shadow Flag
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
        document.body.appendChild(renderer.domElement);

        // Lighting
        scene.add(new THREE.AmbientLight(0x404040));
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5); // Bright sun
        dirLight.position.set(5, 12, 5); // High angle
        dirLight.castShadow = true; 
        // Optimize shadow quality
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // Floor (Receives Shadow)
        const grid = new THREE.GridHelper(30, 30, 0x333333, 0x111111);
        grid.position.y = -4; 
        scene.add(grid);

        // Invisible Shadow Plane (to catch shadows below the grid)
        const planeGeo = new THREE.PlaneGeometry(100, 100);
        const planeMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -4.1; // Just below grid
        plane.receiveShadow = true;
        scene.add(plane);

        // --- INTERACTABLES ---
        const interactables = [];
        const cubeGeo = new THREE.BoxGeometry(2, 2, 2);
        
        function updateObjectPhysics() {
            interactables.forEach(obj => {
                const targetScale = obj.userData.targetScale || 1.0;
                obj.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.2);
                
                if (!obj.userData.isHovered && !obj.userData.isGrabbed) {
                     obj.material.emissive.lerp(new THREE.Color(0x000000), 0.1);
                     obj.userData.targetScale = 1.0;
                }
            });
        }

        const colors = [0xff4444, 0x44ff44, 0x4444ff];
        const positions = [-4, 0, 4];
        
        for(let i=0; i<3; i++) {
            const mat = new THREE.MeshStandardMaterial({ color: colors[i], roughness: 0.2, metalness: 0.1 });
            const cube = new THREE.Mesh(cubeGeo, mat);
            cube.position.set(positions[i], 0, 0); 
            cube.castShadow = true;
            cube.receiveShadow = true;
            cube.userData = { originalColor: colors[i], isHovered: false, isGrabbed: false };
            scene.add(cube);
            interactables.push(cube);
        }

        // --- HAND CONTROLLER ---
        class HandController {
            constructor(color) {
                this.mesh = new THREE.Group();
                
                // Visual Skeleton
                this.joints = [];
                const jointGeo = new THREE.SphereGeometry(0.12, 16, 16); // Smoother spheres
                // UPDATED MATERIAL: Reacts to light + Casts Shadow
                const jointMat = new THREE.MeshStandardMaterial({ 
                    color: color, 
                    roughness: 0.5,
                    emissive: color,
                    emissiveIntensity: 0.2 
                });

                for(let i=0; i<21; i++) {
                    const j = new THREE.Mesh(jointGeo, jointMat);
                    j.castShadow = true; // <--- SHADOWS ENABLED
                    j.receiveShadow = true;
                    this.joints.push(j);
                    this.mesh.add(j);
                }

                // Removed Cursor & TouchBubble Visuals (Logic remains)

                scene.add(this.mesh);

                // State
                this.pinchState = false; 
                this.grabbedObject = null;
                this.grabOffset = new THREE.Vector3();
                this.smoothPos = new THREE.Vector3();
                this.isInitialized = false;
            }

            update(handData) {
                this.mesh.visible = true;
                const lms = handData.landmarks;
                const rawVectors = lms.map(lm => new THREE.Vector3(lm.x * WORLD_SCALE, lm.y * WORLD_SCALE, lm.z * WORLD_SCALE));

                // 1. Calculate Logic Point (Pinch Center)
                const thumbTip = rawVectors[4];
                const indexTip = rawVectors[8];
                const pinchCenter = new THREE.Vector3().lerpVectors(thumbTip, indexTip, 0.5);

                // 2. Smooth Logic Position
                if (!this.isInitialized) {
                    this.smoothPos.copy(pinchCenter);
                    this.isInitialized = true;
                } else {
                    this.smoothPos.lerp(pinchCenter, SMOOTHING);
                }

                // 3. Update Visuals
                for(let i=0; i<21; i++) this.joints[i].position.copy(rawVectors[i]);

                // 4. Interaction (Invisible Logic)
                this.handleInteraction(handData.pinch, this.smoothPos);
            }

            handleInteraction(isPinching, handPos) {
                // A. RELEASE
                if (this.grabbedObject && !isPinching) {
                    this.grabbedObject.userData.isGrabbed = false;
                    this.grabbedObject.userData.targetScale = 1.0; 
                    this.grabbedObject = null;
                }

                // B. DRAG
                if (this.grabbedObject && isPinching) {
                    this.grabbedObject.position.copy(handPos).add(this.grabOffset);
                    this.grabbedObject.userData.targetScale = 0.85; // Stronger squeeze
                    return; 
                }

                // C. FIND TARGET
                let closestObj = null;
                let minDst = GRAB_RADIUS;

                interactables.forEach(obj => {
                    obj.userData.isHovered = false; 
                    const dist = obj.position.distanceTo(handPos);
                    if (dist < minDst) {
                        closestObj = obj;
                        minDst = dist;
                    }
                });

                if (closestObj) {
                    closestObj.userData.isHovered = true;
                    closestObj.userData.targetScale = 1.15; // Stronger pop
                    closestObj.material.emissive.setHex(0x333333);

                    if (isPinching && !this.pinchState) {
                        this.grabbedObject = closestObj;
                        this.grabbedObject.userData.isGrabbed = true;
                        this.grabOffset.subVectors(closestObj.position, handPos);
                    }
                }
                this.pinchState = isPinching;
            }

            hide() { 
                this.mesh.visible = false; 
                this.isInitialized = false; 
            }
        }

        const leftHand = new HandController(0x00ffff);
        const rightHand = new HandController(0xff0000);

        const ws = new WebSocket('ws://localhost:8765');
        const status = document.getElementById('status');

        ws.onmessage = (e) => {
            const data = JSON.parse(e.data);
            updateObjectPhysics();

            let lFound=false, rFound=false;
            if(data.hands) {
                data.hands.forEach(h => {
                    if(h.id === 'Left') { leftHand.update(h); lFound=true; }
                    if(h.id === 'Right') { rightHand.update(h); rFound=true; }
                });
            }
            if(!lFound) leftHand.hide();
            if(!rFound) rightHand.hide();
            status.textContent = `Tracking Active | Hands: ${data.hands.length}`;
        };

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>